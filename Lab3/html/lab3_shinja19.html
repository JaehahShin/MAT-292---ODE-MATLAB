<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>ODE Lab: Creating your own ODE solver in MATLAB</title>
<meta name="generator" content="MATLAB 23.2">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2023-10-20">
<meta name="DC.source" content="lab3_shinja19.m">
<style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style>
</head>
<body>
<div class="content">
<h1>ODE Lab: Creating your own ODE solver in MATLAB</h1>
<!--introduction-->
<p>In this lab, you will write your own ODE solver for the Improved Euler method (also known as the Heun method), and compare its results to those of <tt>ode45</tt>.</p>
<p>You will also learn how to write a function in a separate m-file and execute it.</p>
<p>Opening the m-file lab3.m in the MATLAB editor, step through each part using cell mode to see the results. Compare the output with the PDF, which was generated from this m-file.</p>
<p>There are six (6) exercises in this lab that are to be handed in on the due date. Write your solutions in the template, including appropriate descriptions in each step. Save the .m files and submit them online on Quercus.</p>
<pre class="codeoutput error">Previously accessible file "C:\Users\shinj\AppData\Local\Temp\Editor_qkyhq\LiveEditorEvaluationHelperE1578813082.m" is now
inaccessible.

Error in LiveEditorEvaluationHelperE1578813082&gt;@(t)sin(t.^2+0) (line 227)

Error in lab3_shinja19 (line 137)
fprintf('The actual error computed as %f.\n', abs(xc(end)-y(0.5)));
</pre>
<!--/introduction-->
<h2>Contents</h2>
<div>
<ul>
<li>
<a href="#1">Student Information</a>
</li>
<li>
<a href="#2">Creating new functions using m-files.</a>
</li>
<li>
<a href="#5">Exercise 1</a>
</li>
<li>
<a href="#7">Exercise 2</a>
</li>
<li>
<a href="#8">Exercise 3</a>
</li>
<li>
<a href="#13">Adaptive Step Size</a>
</li>
<li>
<a href="#14">Exercise 4</a>
</li>
<li>
<a href="#15">Exercise 5</a>
</li>
<li>
<a href="#18">Exercise 6</a>
</li>
</ul>
</div>
<h2 id="1">Student Information</h2>
<p>Student Name: Jaehah Shin</p>
<p>Student Number: 1008851137</p>
<h2 id="2">Creating new functions using m-files.</h2>
<p>Create a new function in a separate m-file:</p>
<p>Specifics: Create a text file with the file name f.m with the following lines of code (text):</p>
<pre>function y = f(a,b,c)
y = a+b+c;</pre>
<p>Now MATLAB can call the new function f (which simply accepts 3 numbers and adds them together). To see how this works, type the following in the matlab command window: sum = f(1,2,3)</p>
<pre class="codeinput">
<span class="comment">% sum = f(1,2,3)</span>
</pre>
<h2 id="5">Exercise 1</h2>
<p>Objective: Write your own ODE solver (using the Heun/Improved Euler Method).</p>
<p>Details: This m-file should be a function which accepts as variables (t0,tN,y0,h), where t0 and tN are the start and end points of the interval on which to solve the ODE, y0 is the initial condition of the ODE, and h is the stepsize. You may also want to pass the function into the ODE the way <tt>ode45</tt> does (check lab 2).</p>
<pre class="codeinput">
<span class="comment">% I set the file name as imp_euler.m</span>
<span class="comment">% Use for loop to do this.</span>
<span class="comment">% for loop</span>

<span class="comment">%function [time,Y] = imp_euler(f, t0, tN, y0, h)</span>
 <span class="comment">%   len = round((tN-t0)/h,0);</span>
 <span class="comment">%   time = linspace(t0, tN, len);</span>
  <span class="comment">%  Y = zeros(1, len);</span>
  <span class="comment">%  Y(1) = y0;</span>

<span class="comment">%    for i = 2:len</span>
     <span class="comment">%   S_L = f(time(i-1), Y(i-1));</span>
     <span class="comment">%   S_R = f(time(i), Y(i-1));</span>
     <span class="comment">%   improv_slope = (S_L + S_R) / 2;</span>
      <span class="comment">%  Y(i) = Y(i -1) + h*improv_slope;</span>
  <span class="comment">%  end</span>

   <span class="comment">% plot(time, Y)</span>
  <span class="comment">%  title("Exercies 1: ImprovedODE Solver");</span>
   <span class="comment">% xlabel("t");</span>
  <span class="comment">%  ylabel("y");</span>
    <span class="comment">% --&gt; I commented out this part in .m since I realized that it would be</span>
    <span class="comment">% better to just plot it explicitly.</span>
<span class="comment">% end</span>


<span class="comment">% ODE_solution = imp_euler(f,t0,tN,y0,h);</span>
</pre>
<p>Note: you will need to use a loop to do this exercise. You will also need to recall the Heun/Improved Euler algorithm learned in lectures.</p>
<h2 id="7">Exercise 2</h2>
<p>Objective: Compare Heun with <tt>ode45</tt>.</p>
<p>Specifics: For the following initial-value problems (from lab 2, exercises 1, 4-6), approximate the solutions with your function from exercise 1 (Improved Euler Method). Plot the graphs of your Improved Euler Approximation with the <tt>ode45</tt> approximation.</p>
<p>(a) <tt>y' = y tan t + sin t, y(0) = -1/2</tt> from <tt>t = 0</tt> to <tt>t = pi</tt>
</p>
<p>(b) <tt>y' = 1 / y^2 , y(1) = 1</tt> from <tt>t=1</tt> to <tt>t=10</tt>
</p>
<p>(c) <tt>y' = 1 - t y / 2, y(0) = -1</tt> from <tt>t=0</tt> to <tt>t=10</tt>
</p>
<p>(d) <tt>y' = y^3 - t^2, y(0) = 1</tt> from <tt>t=0</tt> to <tt>t=1</tt>
</p>
<p>Comment on any major differences, or the lack thereof. You do not need to reproduce all the code here. Simply make note of any differences for each of the four IVPs.</p>
<pre class="codeinput">
<span class="comment">% (a)</span>
<span class="comment">% for ODE45</span>
f_a = @(t,y) y.*tan(t) + sin(t);
<span class="comment">% The initial conditions</span>
t0 = 0;
tN = pi;
y0 = -1/2;
sol_by_45 = ode45(f_a, [t0, tN], y0);
<span class="comment">% my ODE solver (Improved Euler)</span>
[Imp_x, Imp_y] = lab3_shinja19_imp_euler(f_a, t0,tN,y0,0.001);
subplot(2,2,1);
plot(sol_by_45.x, sol_by_45.y, Imp_x, Imp_y);
legend(<span class="string">'ODE45'</span>, <span class="string">'My ODE'</span>, <span class="string">'Location'</span>, <span class="string">'Best'</span>);
title(<span class="string">"2.a) y' = y*(tan(t))+(sin(t))"</span>);
ylabel(<span class="string">'y'</span>);
xlabel(<span class="string">'t'</span>);
<span class="comment">% For a, which is y' = y tan t + sin t, no major difference is noticed. As</span>
<span class="comment">% the graph is shown, other than My ODE line is more smoother than ODE 45,</span>
<span class="comment">% the line looks similar from each other.</span>

<span class="comment">% (b)</span>
f_b = @(t,y) 1/(y^2)
t0 = 1;
y0 = 1;
tN = 10;
sol_45 = ode45(f_b, [t0, tN], y0);
[Imp_x, Imp_y] = lab3_shinja19_imp_euler(f_b, t0,tN,y0,0.001);
subplot(2,2,2);
plot(sol_45.x, sol_45.y, Imp_x, Imp_y);
legend(<span class="string">'ODE 45'</span>, <span class="string">'My ODE'</span>,<span class="string">'Location'</span>,<span class="string">'Best'</span>);
title(<span class="string">"2.b) y' = 1 / y^2 "</span>)
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">"y"</span>);
<span class="comment">% For b, which is y' = 1 / y^2, there was no major difference between my</span>
<span class="comment">% ODE and ODE 45. However, as I mentioned in a), My ODE is smoother than</span>
<span class="comment">% ODE 45. Specifically, you can see in ODE 45, more larger gap between two</span>
<span class="comment">% points can be noticed between 1 and 2.5</span>

<span class="comment">% (c)</span>
f_c = @(t,y) 1-t*y/2;
t0 = 0;
y0 = -1;
tN = 10;
sol45 = ode45(f_c, [t0, tN], y0);
[Imp_x, Imp_y] = lab3_shinja19_imp_euler(f_c, t0,tN,y0,0.001);
subplot(2,2,3)
plot(sol45.x, sol45.y, Imp_x, Imp_y );
xlabel(<span class="string">"t"</span>);
ylabel(<span class="string">"y"</span>);
title(<span class="string">"2.c)y' = 1 - t y / 2"</span>);
legend(<span class="string">"ODE45"</span>, <span class="string">"My ODE"</span>, <span class="string">"Location"</span>, <span class="string">"Best"</span>);

<span class="comment">% For c, this behaves simliar to other graphs too. First of all, ODE 45 and</span>
<span class="comment">% MY ODE has simliar solution. However, My ODE is more smoother, and has</span>
<span class="comment">% smaller steps comparing to ODE45.</span>


<span class="comment">% (d)</span>
f_d = @(t,y) y.^3 -t.^2;
t0 = 0;
y0 = 1;
tN = 1;
so_l45 = ode45(f_d, [t0, tN], y0);
[Imp_x, Imp_y] = lab3_shinja19_imp_euler(f_d, t0,tN,y0,0.001);
subplot(2,2,4)
plot(so_l45.x, so_l45.y, Imp_x, Imp_y);
xlabel(<span class="string">"t"</span>)
ylabel(<span class="string">"y"</span>)
title(<span class="string">"2.d) y' = y^3 - t^2"</span>)
legend(<span class="string">"ODE45"</span>, <span class="string">"My ODE"</span>, <span class="string">"Location"</span>, <span class="string">"Best"</span>)
<span class="comment">% For d, The solution couldn't wasn't able to be plotted in lab 2 when I was using</span>
<span class="comment">% ODE 45. when it goes a little bit above 0.5, it goes up to</span>
<span class="comment">% ~10.^22. The orange line which is the solution of My ODE also can't</span>
<span class="comment">% compute this integral. Therefore, this indicates they behave similiary.</span>
<span class="comment">% (ODE 45 goes up to 10.^7, while My ODE goes to 10.^22)</span>
<span class="comment">% Warning: Failure at t=5.066046e-01.  Unable to meet integration tolerances without reducing the step size below the smallest value allowed (1.776357e-15) at time t.</span>
</pre>
<h2 id="8">Exercise 3</h2>
<p>Objective: Use Euler's method and verify an estimate for the global error.</p>
<p>Details:</p>
<p>(a) Use Euler's method (you can use euler.m from iode) to solve the IVP</p>
<p>
<tt>y' = 2 t sqrt( 1 - y^2 ) , y(0) = 0</tt>
</p>
<p>from <tt>t=0</tt> to <tt>t=0.5</tt>.</p>
<pre class="codeinput">xc=euler(@(t,y) 2.*t.*sqrt(1-y.^2) , 0, 0:0.01:0.5);
<span class="comment">%function xc=euler(fs,x0,tc);</span>
xc(end)
</pre>
<p>(b) Calculate the solution of the IVP and evaluate it at <tt>t=0.5</tt>.</p>
<pre class="codeinput">
<span class="comment">% If we solve the ODE, this gives y = sin(t^2 + C)</span>
<span class="comment">% As we have initial values, we can just simply compute to evaluate C.</span>
<span class="comment">% This will give us C = 0 as initial value is (0,0)</span>
fprintf(<span class="string">'Solution of IVP at t = 0.5 y(0.5): %f. \n'</span>, sin(0.5^2));
</pre>
<p>(c) Read the attached derivation of an estimate of the global error for Euler's method. Type out the resulting bound for En here in a comment. Define each variable.</p>
<pre class="codeinput">
<span class="comment">% E_n = (1+M)/2 * dt * M * dt * n</span>
<span class="comment">% E_n = error at n</span>
<span class="comment">% M = [t0, tN]: there exists an M &gt; 0 so that |f | &le; M , |&part;tf | &le; M , and |&part;yf | &le; M .</span>
<span class="comment">% in this case this is Maximum of f</span>
<span class="comment">% dt = h = time = step size which is 0.01 in my case.</span>
<span class="comment">% n = number of steps, = 100 in here</span>
<span class="comment">% f = 2 t sqrt( 1 - y^2 )</span>
<span class="comment">% &part;tf = 2*sqrt( 1 - y^2 )</span>
<span class="comment">% &part;yf = t*(1-y^2)^(-1/2)*(-2y)</span>

t = 0:0.01:0.5;
f = 2.*t.*sqrt(1-xc.^2);
d_tf = 2.*sqrt(1-xc.^2);
d_yf = t.*(1-xc.^2).^(-1/2).*(-2*xc);

max(abs(f));
max(abs(d_tf));
max(abs(d_yf));

M = max(abs(d_tf)) ;
dt = 0.01;
n = 100;
E_n = (1+M)/2 * dt * M * dt * n
<span class="comment">% resulting bound of error is  &plusmn;0.0300</span>
</pre>
<p>(d) Compute the error estimate for <tt>t=0.5</tt> and compare with the actual error.</p>
<pre class="codeinput">fprintf(<span class="string">'With a step size of 0.01 and n = 100, the error bound is %f.\n'</span>, E_n);
fprintf(<span class="string">'The actual error computed as %f.\n'</span>, abs(xc(end)-y(0.5)));
error_difference = abs(abs(xc(end)-y(0.5) - E_n));
fprintf(<span class="string">'Error Difference: %f\n'</span>, error_difference);
</pre>
<p>(e) Change the time step and compare the new error estimate with the actual error. Comment on how it confirms the order of Euler's method.</p>
<pre class="codeinput">xc=euler(@(t, y) 2*t*sqrt(1-y.^2), 0, 0:0.001:0.5);
t = 0:0.001:0.5;
f = 2.*t.*sqrt(1-xc.^2);
dtf = 2.*sqrt(1-xc.^2);
dyf = t.*(1-xc.^2).^(-1/2).*(-2*xc);

max(abs(f));
max(abs(dtf));
max(abs(dyf));

M = max(abs(dtf));
dt = 0.001;
n = 100;
E_n = (1+M)/2 * dt * M * dt * n
fprintf(<span class="string">'With a step size of 0.001 and n = 100, the error bound is %f.\n'</span>, E_n);
fprintf(<span class="string">'The actual error computed as %f.\n'</span>, abs(xc(end)-y(0.5)));


<span class="comment">% As euler's method is 1st order, the time step and error should be</span>
<span class="comment">% proportional each other. As I did 0.1 of previous one for time step, I</span>
<span class="comment">% could see that error bound and actual error also gt 0.1. Therefore, I can</span>
<span class="comment">% say that this is first order euler's method.</span>
</pre>
<h2 id="13">Adaptive Step Size</h2>
<p>As mentioned in lab 2, the step size in <tt>ode45</tt> is adapted to a specific error tolerance.</p>
<p>The idea of adaptive step size is to change the step size <tt>h</tt> to a smaller number whenever the derivative of the solution changes quickly. This is done by evaluating f(t,y) and checking how it changes from one iteration to the next.</p>
<h2 id="14">Exercise 4</h2>
<p>Objective: Create an Adaptive Euler method, with an adaptive step size <tt>h</tt>.</p>
<p>Details: Create an m-file which accepts the variables <tt>(t0,tN,y0,h)</tt>, as in exercise 1, where <tt>h</tt> is an initial step size. You may also want to pass the function into the ODE the way <tt>ode45</tt> does.</p>
<p>Create an implementation of Euler's method by modifying your solution to exercise 1. Change it to include the following:</p>
<p>(a) On each timestep, make two estimates of the value of the solution at the end of the timestep: <tt>Y</tt> from one Euler step of size <tt>h</tt> and <tt>Z</tt> from two successive Euler steps of size <tt>h/2</tt>. The difference in these two values is an estimate for the error.</p>
<p>(b) Let <tt>tol=1e-8</tt> and <tt>D=Z-Y</tt>. If <tt>abs(D)&lt;tol</tt>, declare the step to be successful and set the new solution value to be <tt>Z+D</tt>. This value has local error <tt>O(h^3)</tt>. If <tt>abs(D)&gt;=tol</tt>, reject this step and repeat it with a new step size, from (c).</p>
<p>(c) Update the step size as <tt>h = 0.9*h*min(max(tol/abs(D),0.3),2)</tt>.</p>
<p>Comment on what the formula for updating the step size is attempting to achieve.</p>
<pre class="codeinput">
<span class="comment">% The updated step size is attempting to reduce the step size (h) whenever</span>
<span class="comment">% our error is larger than the tolerance. Also, it multiplies by 0.9, so</span>
<span class="comment">% that they don't take a too big gap to acheive while getting the smaller</span>
<span class="comment">% step size. When the error is under tolerance range, then it won't change</span>
<span class="comment">% the step size and keep the step size as it is. This will achieve to the</span>
<span class="comment">% more precise while applying smaller step size. This prevents when there</span>
<span class="comment">% is higher rate of change, then they can evalute the slope more preciesly.  (with smaller step)</span>

<span class="comment">% function [t, y] = lab3_shinja19_adv_eul(f, t0, tN, y0, h)</span>
<span class="comment">%     t = [t0];</span>
<span class="comment">%     y = [y0];</span>
<span class="comment">%     tol = 1e-8;</span>
<span class="comment">%     function [Y, Z, D] = helper(y, h, t) % Helperfunction with imp_eulder</span>
<span class="comment">%         Y = y + h * f(t, y);</span>
<span class="comment">%         S_L = f(t, y);</span>
<span class="comment">%         S_R = f(t + h, Y);</span>
<span class="comment">%         improv_slope = (S_L + S_R) / 2;</span>
<span class="comment">%         Y = y + h * improv_slope;</span>
<span class="comment">%</span>
<span class="comment">%         Z1_first = y + 0.5 * h * f(t, y);</span>
<span class="comment">%         S_L = f(t, y);</span>
<span class="comment">%         S_R = f(t + 0.5 * h, Z1_first);</span>
<span class="comment">%         improved_slope = (S_L + S_R) / 2;</span>
<span class="comment">%         Z = Z1_first + 0.5 * h * improved_slope;</span>
<span class="comment">%</span>
<span class="comment">%         S_L = f(t + 0.5 * h, Z1_first);</span>
<span class="comment">%         S_R = f(t + h, Z1_first);</span>
<span class="comment">%         improved_slope = (S_L + S_R) / 2;</span>
<span class="comment">%         Z = Z1_first + 0.5 * h * improved_slope;</span>
<span class="comment">%         D = Z - Y;</span>
<span class="comment">%     end</span>
<span class="comment">%</span>
<span class="comment">%     while t(end) &lt; tN</span>
<span class="comment">%         [Y, Z, D] = helper(y(end), h, t(end));</span>
<span class="comment">%         while abs(D) &gt;= tol % check error range</span>
<span class="comment">%             h = 0.9 * h * min(max(tol / abs(D), 0.3), 2);</span>
<span class="comment">%             [Y, Z, D] = helper(y(end), h, t(end));</span>
<span class="comment">%         end</span>
<span class="comment">%         Now everything is good</span>
<span class="comment">%         y = [y, Z + D];</span>
<span class="comment">%         t = [t, t(end) + h];</span>
<span class="comment">%     end</span>
<span class="comment">% end</span>
</pre>
<h2 id="15">Exercise 5</h2>
<p>Objective: Compare Euler to your Adaptive Euler method.</p>
<p>Details: Consider the IVP from exercise 3.</p>
<p>(a) Use Euler method to approximate the solution from <tt>t=0</tt> to <tt>t=0.75</tt> with <tt>h=0.025</tt>.</p>
<pre class="codeinput">xc=euler(@(t, y) 2*t*sqrt(1-y.^2), 0, 0:0.025:0.75);
xc(end)
</pre>
<p>(b) Use your Adaptive Euler method to approximate the solution from <tt>t=0</tt> to <tt>t=0.75</tt> with initial <tt>h=0.025</tt>.</p>
<pre class="codeinput">
<span class="comment">% My new adavtive</span>
[t_adapted, y_adapted] = lab3_shinja19_adv_eul(@(t, y) 2*t*sqrt(1-y.^2), 0, 0.75, 0, 0.025);
<span class="comment">% results_table = table(t_adapted', y_adapted', 'VariableNames', {'Time', 'Solution'});</span>
<span class="comment">% disp(results_table);</span>
<span class="comment">% those are just generating my solutions</span>
</pre>
<p>(c) Plot both approximations together with the exact solution.</p>
<pre class="codeinput">t = 0:0.025:0.75;
figure;
plot(t, xc , t_adapted, y_adapted);
legend(<span class="string">'euler'</span>, <span class="string">'My adv_imp'</span>, <span class="string">'Location'</span>, <span class="string">'Best'</span>);
title(<span class="string">"Exercise 5: Comparing euler and adapted"</span>);
ylabel(<span class="string">'y'</span>);
xlabel(<span class="string">'t'</span>);
</pre>
<h2 id="18">Exercise 6</h2>
<p>Objective: Problems with Numerical Methods.</p>
<p>Details: Consider the IVP from exercise 3 (and 5).</p>
<p>(a) From the two approximations calculated in exercise 5, which one is closer to the actual solution (done in 3.b)? Explain why.</p>
<pre class="codeinput">
<span class="comment">% The answer I got from 3.b was ans = 0.2427.</span>
<span class="comment">% From the graph, I can tell my ADV_imp was more closer to the acutal</span>
<span class="comment">% solution when comparing to euler. The reason behind is ADV_imp method</span>
<span class="comment">% takes the error and if the error is tolearnce, then don't change the step</span>
<span class="comment">% size, but if error is hihger than tolearnce then it makes smaller step</span>
<span class="comment">% size so that it can be under the error tolearnce. That is the reason why</span>
<span class="comment">% ADV_imp is closer to the actual solution.</span>
</pre>
<p>(b) Plot the exact solution (from exercise 3.b), the Euler's approximation (from exercise 3.a) and the adaptive Euler's approximation (from exercise 5) from <tt>t=0</tt> to <tt>t=1.5</tt>.</p>
<pre class="codeinput">xc=euler(@(t, y) 2*t*sqrt(1-y.^2), 0, 0:0.025:1.5);
[t_adapt, y_adapt] = lab3_shinja19_adv_eul(@(t, y) 2*t*sqrt(1-y.^2), 0, 1.5, 0, 0.025);
t = 0:0.025:1.5;
y = @(t) sin(t.^2 + 0);
figure;
plot(t, xc, t_adapt, y_adapt, t, y(t))
title(<span class="string">"Exercise 6: comparing adv vs euler vs exact"</span>);
legend(<span class="string">"euler"</span>, <span class="string">"adaptive"</span>, <span class="string">"exact"</span>, <span class="string">"Location"</span>, <span class="string">"best"</span>);
ylabel(<span class="string">"y"</span>);
xlabel(<span class="string">"t"</span>);
</pre>
<p>(c) Notice how the exact solution and the approximations become very different. Why is that? Write your answer as a comment.</p>
<pre class="codeinput">
<span class="comment">% By looking at the graph, we can tell that euler, adaptive, and the exact</span>
<span class="comment">% solution acting very very differently around pi/2 (approxiamtely 1.5 when</span>
<span class="comment">% assuming pi = 3).</span>
<span class="comment">% Also warning say, imagenry parts of complex X and/ or Y arguments</span>
<span class="comment">% ignored. That is because as  y' = 2 t sqrt( 1 - y^2 ) , y(0) = 0, and</span>
<span class="comment">% when y is greater than 1, it became imagerny number, therefore, they</span>
<span class="comment">% can't handel when y becomes greater than 1.</span>
<span class="comment">%</span>
<span class="comment">% Also, when y is approaching to 1. As we can see from</span>
<span class="comment">% the equation</span>
<span class="comment">% (Function is, y' = 2 t sqrt( 1 - y^2 ) , y(0) = 0),</span>
<span class="comment">% As our approximation is based on</span>
<span class="comment">% y(n+1) = y(n) + h(f(t_n, y(n)) (doesnt matter if we used adaptive or not)</span>
<span class="comment">% since governing euler method is same.</span>
<span class="comment">% As y(n) = 1, then f will be 0, therefore, this result in y(n+1) = y(n).</span>
<span class="comment">% This will result in horizontal slope as shown in euler and adaptvie.</span>
<span class="comment">% This is why they can't continue approximate the derivate correctly when they</span>
<span class="comment">% reached the point of y' = 0. (due to property of f in our approximation)</span>
</pre>
<p class="footer">
<br>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2023b</a>
<br>
</p>
</div>
<!--
##### SOURCE BEGIN #####
%% ODE Lab: Creating your own ODE solver in MATLAB
% In this lab, you will write your own ODE solver for the Improved Euler method 
% (also known as the Heun method), and compare its results to those of |ode45|.
% 
% You will also learn how to write a function in a separate m-file and execute 
% it.
% 
% Opening the m-file lab3.m in the MATLAB editor, step through each part using 
% cell mode to see the results. Compare the output with the PDF, which was generated 
% from this m-file.
% 
% There are six (6) exercises in this lab that are to be handed in on the due 
% date. Write your solutions in the template, including appropriate descriptions 
% in each step. Save the .m files and submit them online on Quercus.
%% Student Information
% Student Name: Jaehah Shin
% 
% Student Number: 1008851137
%% Creating new functions using m-files.
% Create a new function in a separate m-file:
% 
% Specifics: Create a text file with the file name f.m with the following lines 
% of code (text):
%%
% 
%  function y = f(a,b,c) 
%  y = a+b+c;
%
%% 
% Now MATLAB can call the new function f (which simply accepts 3 numbers and 
% adds them together). To see how this works, type the following in the matlab 
% command window: sum = f(1,2,3)

% sum = f(1,2,3)
%% Exercise 1
% Objective: Write your own ODE solver (using the Heun/Improved Euler Method).
% 
% Details: This m-file should be a function which accepts as variables (t0,tN,y0,h), 
% where t0 and tN are the start and end points of the interval on which to solve 
% the ODE, y0 is the initial condition of the ODE, and h is the stepsize. You 
% may also want to pass the function into the ODE the way |ode45| does (check 
% lab 2).

% I set the file name as imp_euler.m
% Use for loop to do this. 
% for loop

%function [time,Y] = imp_euler(f, t0, tN, y0, h)
 %   len = round((tN-t0)/h,0);
 %   time = linspace(t0, tN, len);
  %  Y = zeros(1, len);
  %  Y(1) = y0;

%    for i = 2:len
     %   S_L = f(time(i-1), Y(i-1));
     %   S_R = f(time(i), Y(i-1));
     %   improv_slope = (S_L + S_R) / 2;
      %  Y(i) = Y(i -1) + h*improv_slope;
  %  end 

   % plot(time, Y)
  %  title("Exercies 1: ImprovedODE Solver");
   % xlabel("t");
  %  ylabel("y");
    % REPLACE_WITH_DASH_DASH> I commented out this part in .m since I realized that it would be
    % better to just plot it explicitly. 
% end


% ODE_solution = imp_euler(f,t0,tN,y0,h);
%% 
% Note: you will need to use a loop to do this exercise. You will also need 
% to recall the Heun/Improved Euler algorithm learned in lectures. 
%% Exercise 2
% Objective: Compare Heun with |ode45|.
% 
% Specifics: For the following initial-value problems (from lab 2, exercises 
% 1, 4-6), approximate the solutions with your function from exercise 1 (Improved 
% Euler Method). Plot the graphs of your Improved Euler Approximation with the 
% |ode45| approximation.
% 
% (a) |y' = y tan t + sin t, y(0) = -1/2| from |t = 0| to |t = pi|
% 
% (b) |y' = 1 / y^2 , y(1) = 1| from |t=1| to |t=10|
% 
% (c) |y' = 1 - t y / 2, y(0) = -1| from |t=0| to |t=10|
% 
% (d) |y' = y^3 - t^2, y(0) = 1| from |t=0| to |t=1|
% 
% Comment on any major differences, or the lack thereof. You do not need to 
% reproduce all the code here. Simply make note of any differences for each of 
% the four IVPs.

% (a)
% for ODE45
f_a = @(t,y) y.*tan(t) + sin(t);
% The initial conditions
t0 = 0;
tN = pi;
y0 = -1/2;
sol_by_45 = ode45(f_a, [t0, tN], y0);
% my ODE solver (Improved Euler)
[Imp_x, Imp_y] = lab3_shinja19_imp_euler(f_a, t0,tN,y0,0.001);
subplot(2,2,1);
plot(sol_by_45.x, sol_by_45.y, Imp_x, Imp_y);
legend('ODE45', 'My ODE', 'Location', 'Best');
title("2.a) y' = y*(tan(t))+(sin(t))");
ylabel('y');
xlabel('t');
% For a, which is y' = y tan t + sin t, no major difference is noticed. As
% the graph is shown, other than My ODE line is more smoother than ODE 45,
% the line looks similar from each other. 

% (b)
f_b = @(t,y) 1/(y^2)
t0 = 1;
y0 = 1;
tN = 10;
sol_45 = ode45(f_b, [t0, tN], y0);
[Imp_x, Imp_y] = lab3_shinja19_imp_euler(f_b, t0,tN,y0,0.001);
subplot(2,2,2);
plot(sol_45.x, sol_45.y, Imp_x, Imp_y);
legend('ODE 45', 'My ODE','Location','Best');
title("2.b) y' = 1 / y^2 ")
xlabel('t');
ylabel("y");
% For b, which is y' = 1 / y^2, there was no major difference between my
% ODE and ODE 45. However, as I mentioned in a), My ODE is smoother than
% ODE 45. Specifically, you can see in ODE 45, more larger gap between two
% points can be noticed between 1 and 2.5 

% (c)
f_c = @(t,y) 1-t*y/2;
t0 = 0;
y0 = -1;
tN = 10;
sol45 = ode45(f_c, [t0, tN], y0);
[Imp_x, Imp_y] = lab3_shinja19_imp_euler(f_c, t0,tN,y0,0.001);
subplot(2,2,3)
plot(sol45.x, sol45.y, Imp_x, Imp_y );
xlabel("t");
ylabel("y");
title("2.c)y' = 1 - t y / 2");
legend("ODE45", "My ODE", "Location", "Best");

% For c, this behaves simliar to other graphs too. First of all, ODE 45 and
% MY ODE has simliar solution. However, My ODE is more smoother, and has
% smaller steps comparing to ODE45.


% (d)
f_d = @(t,y) y.^3 -t.^2;
t0 = 0;
y0 = 1;
tN = 1;
so_l45 = ode45(f_d, [t0, tN], y0);
[Imp_x, Imp_y] = lab3_shinja19_imp_euler(f_d, t0,tN,y0,0.001);
subplot(2,2,4)
plot(so_l45.x, so_l45.y, Imp_x, Imp_y);
xlabel("t")
ylabel("y")
title("2.d) y' = y^3 - t^2")
legend("ODE45", "My ODE", "Location", "Best")
% For d, The solution couldn't wasn't able to be plotted in lab 2 when I was using
% ODE 45. when it goes a little bit above 0.5, it goes up to 
% ~10.^22. The orange line which is the solution of My ODE also can't
% compute this integral. Therefore, this indicates they behave similiary.
% (ODE 45 goes up to 10.^7, while My ODE goes to 10.^22)
% Warning: Failure at t=5.066046e-01.  Unable to meet integration tolerances without reducing the step size below the smallest value allowed (1.776357e-15) at time t.
%% Exercise 3
% Objective: Use Euler's method and verify an estimate for the global error.
% 
% Details: 
% 
% (a) Use Euler's method (you can use euler.m from iode) to solve the IVP
% 
% |y' = 2 t sqrt( 1 - y^2 ) , y(0) = 0|
% 
% from |t=0| to |t=0.5|.

xc=euler(@(t,y) 2.*t.*sqrt(1-y.^2) , 0, 0:0.01:0.5);
%function xc=euler(fs,x0,tc);
xc(end)
%% 
% (b) Calculate the solution of the IVP and evaluate it at |t=0.5|.

% If we solve the ODE, this gives y = sin(t^2 + C)
% As we have initial values, we can just simply compute to evaluate C.
% This will give us C = 0 as initial value is (0,0) 
fprintf('Solution of IVP at t = 0.5 y(0.5): %f. \n', sin(0.5^2));
%% 
% (c) Read the attached derivation of an estimate of the global error for Euler's 
% method. Type out the resulting bound for En here in a comment. Define each variable.

% E_n = (1+M)/2 * dt * M * dt * n
% E_n = error at n
% M = [t0, tN]: there exists an M > 0 so that |f | ≤ M , |∂tf | ≤ M , and |∂yf | ≤ M .
% in this case this is Maximum of f
% dt = h = time = step size which is 0.01 in my case. 
% n = number of steps, = 100 in here
% f = 2 t sqrt( 1 - y^2 )
% ∂tf = 2*sqrt( 1 - y^2 )
% ∂yf = t*(1-y^2)^(-1/2)*(-2y)

t = 0:0.01:0.5;
f = 2.*t.*sqrt(1-xc.^2);
d_tf = 2.*sqrt(1-xc.^2);
d_yf = t.*(1-xc.^2).^(-1/2).*(-2*xc);

max(abs(f));
max(abs(d_tf));
max(abs(d_yf));

M = max(abs(d_tf)) ;
dt = 0.01;
n = 100;
E_n = (1+M)/2 * dt * M * dt * n 
% resulting bound of error is  ±0.0300
%% 
% (d) Compute the error estimate for |t=0.5| and compare with the actual error.

fprintf('With a step size of 0.01 and n = 100, the error bound is %f.\n', E_n);
fprintf('The actual error computed as %f.\n', abs(xc(end)-y(0.5)));
error_difference = abs(abs(xc(end)-y(0.5) - E_n));
fprintf('Error Difference: %f\n', error_difference);
%% 
% (e) Change the time step and compare the new error estimate with the actual 
% error. Comment on how it confirms the order of Euler's method.

xc=euler(@(t, y) 2*t*sqrt(1-y.^2), 0, 0:0.001:0.5);
t = 0:0.001:0.5;
f = 2.*t.*sqrt(1-xc.^2);
dtf = 2.*sqrt(1-xc.^2);
dyf = t.*(1-xc.^2).^(-1/2).*(-2*xc);

max(abs(f));
max(abs(dtf));
max(abs(dyf));

M = max(abs(dtf));
dt = 0.001;
n = 100;
E_n = (1+M)/2 * dt * M * dt * n
fprintf('With a step size of 0.001 and n = 100, the error bound is %f.\n', E_n);
fprintf('The actual error computed as %f.\n', abs(xc(end)-y(0.5)));


% As euler's method is 1st order, the time step and error should be
% proportional each other. As I did 0.1 of previous one for time step, I
% could see that error bound and actual error also gt 0.1. Therefore, I can
% say that this is first order euler's method. 
%% Adaptive Step Size
% As mentioned in lab 2, the step size in |ode45| is adapted to a specific error 
% tolerance.
% 
% The idea of adaptive step size is to change the step size |h| to a smaller 
% number whenever the derivative of the solution changes quickly. This is done 
% by evaluating f(t,y) and checking how it changes from one iteration to the next.
%% Exercise 4
% Objective: Create an Adaptive Euler method, with an adaptive step size |h|.
% 
% Details: Create an m-file which accepts the variables |(t0,tN,y0,h)|, as in 
% exercise 1, where |h| is an initial step size. You may also want to pass the 
% function into the ODE the way |ode45| does.
% 
% Create an implementation of Euler's method by modifying your solution to exercise 
% 1. Change it to include the following:
% 
% (a) On each timestep, make two estimates of the value of the solution at the 
% end of the timestep: |Y| from one Euler step of size |h| and |Z| from two successive 
% Euler steps of size |h/2|. The difference in these two values is an estimate 
% for the error.
% 
% (b) Let |tol=1e-8| and |D=Z-Y|. If |abs(D)<tol|, declare the step to be successful 
% and set the new solution value to be |Z+D|. This value has local error |O(h^3)|. 
% If |abs(D)>=tol|, reject this step and repeat it with a new step size, from 
% (c).
% 
% (c) Update the step size as |h = 0.9*h*min(max(tol/abs(D),0.3),2)|.
% 
% Comment on what the formula for updating the step size is attempting to achieve.

% The updated step size is attempting to reduce the step size (h) whenever
% our error is larger than the tolerance. Also, it multiplies by 0.9, so
% that they don't take a too big gap to acheive while getting the smaller
% step size. When the error is under tolerance range, then it won't change
% the step size and keep the step size as it is. This will achieve to the
% more precise while applying smaller step size. This prevents when there
% is higher rate of change, then they can evalute the slope more preciesly.  (with smaller step)

% function [t, y] = lab3_shinja19_adv_eul(f, t0, tN, y0, h)
%     t = [t0];
%     y = [y0];
%     tol = 1e-8;
%     function [Y, Z, D] = helper(y, h, t) % Helperfunction with imp_eulder 
%         Y = y + h * f(t, y);
%         S_L = f(t, y);
%         S_R = f(t + h, Y);
%         improv_slope = (S_L + S_R) / 2;
%         Y = y + h * improv_slope;
% 
%         Z1_first = y + 0.5 * h * f(t, y);
%         S_L = f(t, y);
%         S_R = f(t + 0.5 * h, Z1_first);
%         improved_slope = (S_L + S_R) / 2;
%         Z = Z1_first + 0.5 * h * improved_slope;
% 
%         S_L = f(t + 0.5 * h, Z1_first);
%         S_R = f(t + h, Z1_first);
%         improved_slope = (S_L + S_R) / 2;
%         Z = Z1_first + 0.5 * h * improved_slope;
%         D = Z - Y;
%     end
% 
%     while t(end) < tN
%         [Y, Z, D] = helper(y(end), h, t(end));
%         while abs(D) >= tol % check error range 
%             h = 0.9 * h * min(max(tol / abs(D), 0.3), 2);
%             [Y, Z, D] = helper(y(end), h, t(end));
%         end
%         Now everything is good 
%         y = [y, Z + D];
%         t = [t, t(end) + h];
%     end
% end

%% Exercise 5
% Objective: Compare Euler to your Adaptive Euler method.
% 
% Details: Consider the IVP from exercise 3.
% 
% (a) Use Euler method to approximate the solution from |t=0| to |t=0.75| with 
% |h=0.025|.

xc=euler(@(t, y) 2*t*sqrt(1-y.^2), 0, 0:0.025:0.75);
xc(end)
%% 
% (b) Use your Adaptive Euler method to approximate the solution from |t=0| 
% to |t=0.75| with initial |h=0.025|.

% My new adavtive 
[t_adapted, y_adapted] = lab3_shinja19_adv_eul(@(t, y) 2*t*sqrt(1-y.^2), 0, 0.75, 0, 0.025);
% results_table = table(t_adapted', y_adapted', 'VariableNames', {'Time', 'Solution'});
% disp(results_table);
% those are just generating my solutions
%% 
% (c) Plot both approximations together with the exact solution.

t = 0:0.025:0.75;
figure; 
plot(t, xc , t_adapted, y_adapted);
legend('euler', 'My adv_imp', 'Location', 'Best');
title("Exercise 5: Comparing euler and adapted");
ylabel('y');
xlabel('t');
%% Exercise 6
% Objective: Problems with Numerical Methods.
% 
% Details: Consider the IVP from exercise 3 (and 5).
% 
% (a) From the two approximations calculated in exercise 5, which one is closer 
% to the actual solution (done in 3.b)? Explain why.

% The answer I got from 3.b was ans = 0.2427. 
% From the graph, I can tell my ADV_imp was more closer to the acutal
% solution when comparing to euler. The reason behind is ADV_imp method
% takes the error and if the error is tolearnce, then don't change the step
% size, but if error is hihger than tolearnce then it makes smaller step
% size so that it can be under the error tolearnce. That is the reason why
% ADV_imp is closer to the actual solution. 
%% 
% (b) Plot the exact solution (from exercise 3.b), the Euler's approximation 
% (from exercise 3.a) and the adaptive Euler's approximation (from exercise 5) 
% from |t=0| to |t=1.5|.

xc=euler(@(t, y) 2*t*sqrt(1-y.^2), 0, 0:0.025:1.5);
[t_adapt, y_adapt] = lab3_shinja19_adv_eul(@(t, y) 2*t*sqrt(1-y.^2), 0, 1.5, 0, 0.025);
t = 0:0.025:1.5;
y = @(t) sin(t.^2 + 0);
figure;
plot(t, xc, t_adapt, y_adapt, t, y(t))
title("Exercise 6: comparing adv vs euler vs exact");
legend("euler", "adaptive", "exact", "Location", "best");
ylabel("y");
xlabel("t");
%% 
% (c) Notice how the exact solution and the approximations become very different. 
% Why is that? Write your answer as a comment.

% By looking at the graph, we can tell that euler, adaptive, and the exact
% solution acting very very differently around pi/2 (approxiamtely 1.5 when
% assuming pi = 3). 
% Also warning say, imagenry parts of complex X and/ or Y arguments
% ignored. That is because as  y' = 2 t sqrt( 1 - y^2 ) , y(0) = 0, and
% when y is greater than 1, it became imagerny number, therefore, they
% can't handel when y becomes greater than 1. 
% 
% Also, when y is approaching to 1. As we can see from
% the equation 
% (Function is, y' = 2 t sqrt( 1 - y^2 ) , y(0) = 0),
% As our approximation is based on
% y(n+1) = y(n) + h(f(t_n, y(n)) (doesnt matter if we used adaptive or not)
% since governing euler method is same.
% As y(n) = 1, then f will be 0, therefore, this result in y(n+1) = y(n).
% This will result in horizontal slope as shown in euler and adaptvie.
% This is why they can't continue approximate the derivate correctly when they
% reached the point of y' = 0. (due to property of f in our approximation)
##### SOURCE END #####
-->
</body>
</html>
