<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>Integrator Lab: Solving First Order ODEs in MATLAB and Picard Approximation</title>
<meta name="generator" content="MATLAB 23.2">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2023-10-02">
<meta name="DC.source" content="lab2_shinja19.m">
<style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style>
</head>
<body>
<div class="content">
<h1>Integrator Lab: Solving First Order ODEs in MATLAB and Picard Approximation</h1>
<!--introduction-->
<p>This lab will teach you to numerically solve first order ODEs using a built in MATLAB integrator, <tt>ode45</tt>.  <tt>ode45</tt> is a good, general purpose tool for integrating first order equations (and first order systems). It is not always the right algorithm, but it is usually the right algorithm to try first. This lab will also teach you how to manipulate symbolic functions in MATLAB.</p>
<p>You will learn how to use the <tt>ode45</tt> routine, how to interpolate between points, and how MATLAB handles data structures. You will also learn how to use MATLAB for exact symbolic calculations and write your own Picard approximation code.</p>
<p>Opening the m-file lab2.m in the MATLAB editor, step through each part using cell mode to see the results. Compare the output with the PDF, which was generated from this m-file.</p>
<p>There are eight exercises in this lab that are to be handed in at the end of the lab. Write your solutions in the template, including appropriate descriptions in each step. Save the .m file and submit it online using Quercus.</p>
<!--/introduction-->
<h2>Contents</h2>
<div>
<ul>
<li>
<a href="#1">Student Information</a>
</li>
<li>
<a href="#2">Set up an inline function representation of an ODE and solve it</a>
</li>
<li>
<a href="#3">Examining the output</a>
</li>
<li>
<a href="#4">Understanding the components of the solution data structure</a>
</li>
<li>
<a href="#5">Visualizing and comparing the solution</a>
</li>
<li>
<a href="#6">Exercise 1</a>
</li>
<li>
<a href="#8">Computing an approximation at a specific point</a>
</li>
<li>
<a href="#9">Exercise 2</a>
</li>
<li>
<a href="#11">Errors, Step Sizes, and Tolerances</a>
</li>
<li>
<a href="#12">Exercise 3</a>
</li>
<li>
<a href="#14">Exercise 4</a>
</li>
<li>
<a href="#16">Exercise 5</a>
</li>
<li>
<a href="#18">Exercise 6 - When things go wrong</a>
</li>
<li>
<a href="#20">Using symbolic variables to define functions</a>
</li>
<li>
<a href="#23">Exercise 7</a>
</li>
<li>
<a href="#24">Obtaining Picard approximations</a>
</li>
<li>
<a href="#25">Exercise 8</a>
</li>
</ul>
</div>
<h2 id="1">Student Information</h2>
<p>Student Name: Jaehah Shin</p>
<p>Student Number: 1008851137</p>
<h2 id="2">Set up an inline function representation of an ODE and solve it</h2>
<p>MATLAB has many built in routines for solving differential equations of the form</p>
<p>
<tt>y' = f(t,y)</tt>
</p>
<p>We will solve them using <tt>ode45</tt>, a high precision integrator. To do this, we will need to construct an inline function representation of <tt>f</tt>, an initial condition, and specify how far we want MATLAB to integrate the problem. Once we have set these, we pass the information to <tt>ode45</tt> to get the solution.</p>
<p>For a first example, we will solve the initial value problem</p>
<p>
<tt>y' = y, y(0) = 1</tt>
</p>
<p>which has as its answer <tt>y = e^t</tt>.</p>
<pre class="codeinput">
<span class="comment">% Set up the right hand side of the ODE as an inline function</span>
f = @(t,y) y;

<span class="comment">% The initial conditions</span>
t0 = 0;
y0 = 1;

<span class="comment">% The time we will integrate until</span>
t1 = 2;

soln = ode45(f, [t0, t1], y0);
</pre>
<h2 id="3">Examining the output</h2>
<p>When we execute the <tt>ode45</tt>, it returns a data structure, stored in soln. We can see the pieces of the data structure with a display command:</p>
<pre class="codeinput">disp(soln);
</pre>
<pre class="codeoutput">     solver: 'ode45'
    extdata: [1&times;1 struct]
          x: [0 0.2000 0.4000 0.6000 0.8000 1 1.2000 1.4000 1.6000 1.8000 2]
          y: [1 1.2214 1.4918 1.8221 2.2255 2.7183 3.3201 &hellip; ] (1&times;11 double)
      stats: [1&times;1 struct]
      idata: [1&times;1 struct]

</pre>
<h2 id="4">Understanding the components of the solution data structure</h2>
<p>The most important elements of the data structure are stored in the <tt>x</tt> and <tt>y</tt> components of the structure; these are vectors. Vectors <tt>x</tt> and <tt>y</tt> contain the points at which the numerical approximation to the initial vlaue problem has been computed. In other words, <tt>y(j)</tt> is the approximate value of the solution at <tt>x(j)</tt>.</p>
<p>
<b>NOTE:</b> Even though we may be studying a problem like <tt>u(t)</tt> or <tt>y(t)</tt>, MATLAB will always use <tt>x</tt> for the independent variable and <tt>y</tt> for the dependent variable in the data structure.</p>
<p>Pieces of the data structure can be accessed using a period, as in C/C++ or Java. See the examples below:</p>
<pre class="codeinput">
<span class="comment">% Display the values of |t| at which |y(t)| is approximated</span>
fprintf(<span class="string">' Vector of t values: '</span>);
disp(soln.x);
<span class="comment">% Display the the corresponding approximatations of |y(t)|</span>
fprintf(<span class="string">' Vector of y values: '</span>);
disp(soln.y);

<span class="comment">% Display the approximation of the solution at the 3rd point:</span>
fprintf(<span class="string">' Third element of the vector of t values: %g\n'</span>,soln.x(3));
fprintf(<span class="string">' Third element of the vector of y values: %g\n'</span>,soln.y(3));
</pre>
<pre class="codeoutput"> Vector of t values:   Columns 1 through 7

         0    0.2000    0.4000    0.6000    0.8000    1.0000    1.2000

  Columns 8 through 11

    1.4000    1.6000    1.8000    2.0000

 Vector of y values:   Columns 1 through 7

    1.0000    1.2214    1.4918    1.8221    2.2255    2.7183    3.3201

  Columns 8 through 11

    4.0552    4.9530    6.0496    7.3891

 Third element of the vector of t values: 0.4
 Third element of the vector of y values: 1.49182
</pre>
<h2 id="5">Visualizing and comparing the solution</h2>
<p>We can now visualize the solution at the computed data points and compare with the exact solution.</p>
<pre class="codeinput">
<span class="comment">% Construct the exact solution</span>
tt = linspace(0,2,50);
yy = exp(tt);

<span class="comment">% Plot both on the same figure, plotting the approximation with x's</span>
plot(tt, yy, soln.x, soln.y, <span class="string">'x'</span>, <span class="string">'MarkerSize'</span>,10, <span class="string">'LineWidth'</span>, 2);
<span class="comment">% NOTE: the MarkerSize and LineWidth are larger than their defaults of 6</span>
<span class="comment">% and 1, respectively.  This makes the print out more readable.</span>

<span class="comment">% Add a label to the axis and a legend</span>
xlabel(<span class="string">'t'</span>);
legend(<span class="string">'Exact'</span>, <span class="string">'Numerical'</span>,<span class="string">'Location'</span>,<span class="string">'Best'</span>);
</pre>
<img vspace="5" hspace="5" src="lab2_shinja19_01.png" alt=""> <h2 id="6">Exercise 1</h2>
<p>Objective: Solve an initial value problem and plot both the numerical approximation and the corresponding exact solution.</p>
<p>Details: Solve the IVP</p>
<p>
<tt>y' = y tan t + sin t, y(0) = -1/2</tt>
</p>
<p>from <tt>t = 0</tt> to <tt>t = pi</tt>.</p>
<p>Compute the exact solution (by hand), and plot both on the same figure for comparison, as above.</p>
<pre class="codeinput">
<span class="comment">% Set up the right hand side of the ODE as an inline function</span>
f = @(t,y) y*tan(t) + sin(t);

<span class="comment">% The initial conditions</span>
t0 = 0;
y0 = -1/2;

<span class="comment">% The time we will integrate until</span>
t1 = pi;

sol_by_45 = ode45(f, [t0, t1], y0);
disp(sol_by_45);
<span class="comment">%      solver: 'ode45'</span>
<span class="comment">%    extdata: [1&times;1 struct]</span>
<span class="comment">%          x: [0 0.3142 0.6283 0.9425 1.2566 1.2881 1.3195 1.4765 1.5177 1.5588 1.6491 1.7455 2.0597 2.3739 2.6880 3.0022 3.1416]</span>
<span class="comment">%          y: [-0.5000 -0.4755 -0.4045 -0.2939 -0.1545 -0.1395 -0.1243 -0.0471 -0.0266 -0.0060 0.0391 0.0869 0.2348 0.3597 0.4494 0.4951 0.5000]</span>
<span class="comment">%      stats: [1&times;1 struct]</span>
<span class="comment">%      idata: [1&times;1 struct]</span>

<span class="comment">% Now solve by hand.</span>

<span class="comment">% use integartion factor to solve this.</span>
<span class="comment">% This will lead to y = (sin^2t / 2cost) -0.5 /cost</span>
<span class="comment">% (y = sin^2(t)/2cost) + C/cost before putting intinal conditions)</span>
<span class="comment">% By solving constant with intial condition yields</span>
<span class="comment">% C = -0.5, which will lead to above equation.</span>
tt = linspace(0, pi, 50);
yy = (sin(tt).^2)./(2*cos(tt)) - 0.5./(cos(tt));



<span class="comment">% Plot both on the same figure, plotting the approximation with x's</span>
plot(tt, yy, sol_by_45.x, sol_by_45.y, <span class="string">'x'</span>, <span class="string">'MarkerSize'</span>,10, <span class="string">'LineWidth'</span>, 2);
<span class="comment">% NOTE: the MarkerSize and LineWidth are larger than their defaults of 6</span>
<span class="comment">% and 1, respectively.  This makes the print out more readable.</span>

<span class="comment">% Add a label to the axis and a legend</span>
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">"y"</span>);
legend(<span class="string">'By Hand'</span>, <span class="string">'ODE 45'</span>,<span class="string">'Location'</span>,<span class="string">'Best'</span>);
title(<span class="string">"Exercise 1: Hand vs. ODE 45"</span>)
</pre>
<pre class="codeoutput">     solver: 'ode45'
    extdata: [1&times;1 struct]
          x: [0 0.3142 0.6283 0.9425 1.2566 1.2881 1.3195 &hellip; ] (1&times;17 double)
          y: [-0.5000 -0.4755 -0.4045 -0.2939 -0.1545 &hellip; ] (1&times;17 double)
      stats: [1&times;1 struct]
      idata: [1&times;1 struct]

</pre>
<img vspace="5" hspace="5" src="lab2_shinja19_02.png" alt=""> <p>Your submission should show the construction of the inline function, the use of ode45 to obtain the solution, a construction of the exact solution, and a plot showing both. In the comments, include the exact solution.</p>
<p>Label your axes and include a legend.</p>
<h2 id="8">Computing an approximation at a specific point</h2>
<p>As you should be able to see by examining <tt>soln.x</tt>, ode45 returns the solution at a number of points between <tt>t0</tt> and <tt>t1</tt>. But sometimes we want to know the solution at some intermediate point.</p>
<p>To obtain this value, we need to interpolate it in a consistent way. Fortunately, MATLAB provides a convenient function, <tt>deval</tt>, specifically for this.</p>
<pre class="codeinput">
<span class="comment">% Compute the solution at t = .25:</span>
deval(soln, .25)

<span class="comment">% Compute the solution at t = 1.6753:</span>
fprintf(<span class="string">' Solution at 1.6753: %g\n'</span>, deval(soln, 1.6753));

<span class="comment">% Compute the solution at 10 grid points between .45 and 1.65:</span>
tinterp = linspace(.45, 1.65, 10);
deval(soln, tinterp)

<span class="comment">% Alternatively:</span>
deval(soln, linspace(.45, 1.65, 10))
</pre>
<pre class="codeoutput">
ans =

    1.2840

 Solution at 1.6753: 5.3404

ans =

  Columns 1 through 7

    1.5683    1.7920    2.0476    2.3396    2.6734    3.0547    3.4903

  Columns 8 through 10

    3.9882    4.5570    5.2070


ans =

  Columns 1 through 7

    1.5683    1.7920    2.0476    2.3396    2.6734    3.0547    3.4903

  Columns 8 through 10

    3.9882    4.5570    5.2070

</pre>
<h2 id="9">Exercise 2</h2>
<p>Objective: Interpolate a solution at a number of grid points</p>
<pre class="codeinput">hi = deval(sol_by_45, linspace(2,3,10))
disp(hi);

<span class="comment">% double check where the bottom colum come from</span>
</pre>
<pre class="codeoutput">
hi =

  Columns 1 through 7

    0.2081    0.2572    0.3032    0.3454    0.3833    0.4166    0.4447

  Columns 8 through 10

    0.4673    0.4841    0.4950

  Columns 1 through 7

    0.2081    0.2572    0.3032    0.3454    0.3833    0.4166    0.4447

  Columns 8 through 10

    0.4673    0.4841    0.4950

</pre>
<p>Details: For the solution you computed in exercise 1, use deval to compute the interpolated values at 10 grid points between 2 and 3.</p>
<h2 id="11">Errors, Step Sizes, and Tolerances</h2>
<p>As you may have noticed, in contrast to the IODE software, at no point do we set a step size for our solution. Indeed, the step size is set adaptively to conform to a specified error tolerance.</p>
<p>Roughly speaking, given the solution at <tt>(t_j, y_j)</tt>, <tt>ode45</tt> computes two approximations of the solution at <tt>t_{j+1} = t_j + h</tt>; one is of greater accuracy than the other. If the difference is below a specified tolerance, the step is accepted and we continue. Otherwise the step is rejected and the smaller step size, <tt>h</tt>, is used; it is often halved.</p>
<p>We can compute the global truncation error at each solution point, figure out the maximum error, and visualize this error (on a linear-log scale):</p>
<pre class="codeinput">
<span class="comment">% Compute the exact solution</span>
yexact = exp(soln.x);

<span class="comment">% Compute the pointwise error; note the use of MATLAB's vectorization</span>
err = abs(yexact - soln.y);

disp(err);

fprintf(<span class="string">'maximum error: %g \n'</span>, max(err));

semilogy(soln.x, err, <span class="string">'LineWidth'</span>, 2);
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'error'</span>);
</pre>
<pre class="codeoutput">   1.0e-06 *

  Columns 1 through 7

         0    0.0152    0.0371    0.0679    0.1106    0.1688    0.2475

  Columns 8 through 11

    0.3526    0.4922    0.6764    0.9179

maximum error: 9.17923e-07 
</pre>
<img vspace="5" hspace="5" src="lab2_shinja19_03.png" alt=""> <h2 id="12">Exercise 3</h2>
<p>Objective: Examine the error of a solution generated by <tt>ode45</tt>
</p>
<pre class="codeinput">
<span class="comment">% computing the exact solutino:</span>
yexact = (sin(sol_by_45.x).^2)./(2*cos(sol_by_45.x)) - 0.5./(cos(sol_by_45.x));

<span class="comment">% Error?</span>
ERROR = abs(yexact - sol_by_45.y);
disp(ERROR);
fprintf(<span class="string">"Maximum ERROR: %g \n"</span>, max(ERROR));
<span class="comment">% Maximum ERROR: 1.8068e-05</span>

<span class="comment">% Error is largest at that point near t = 1.5,</span>
<span class="comment">% the reason because it has the largest error is as at @ 1.5s is the rate of</span>
<span class="comment">% chage of the derivate is the higest. Smaller steps</span>
<span class="comment">% sizes are required to reduce the error.</span>
semilogy(sol_by_45.x, ERROR, <span class="string">"LineWidth"</span>, 2);
xlabel(<span class="string">"t"</span>);
ylabel(<span class="string">"ERROR"</span>);
title(<span class="string">"Exercise 3"</span>)
</pre>
<pre class="codeoutput">   1.0e-04 *

  Columns 1 through 7

         0    0.0001    0.0006    0.0021    0.0070    0.0077    0.0087

  Columns 8 through 14

    0.0230    0.0408    0.1807    0.0254    0.0114    0.0068    0.0055

  Columns 15 through 17

    0.0047    0.0043    0.0043

Maximum ERROR: 1.8068e-05 
</pre>
<img vspace="5" hspace="5" src="lab2_shinja19_04.png" alt=""> <p>Details: For your solution to exercise 1, compute the pointwise error, identify the maximum value of the error, and visualize the error on a linear-log plot (use semilogy to plot the log of the error vs. t). Write in the comments where the error is largest, and give a brief (1-2 sentences) explanation of why it is largest there. Make sure to label your axes.</p>
<h2 id="14">Exercise 4</h2>
<p>Objective: Solve and visualize a nonlinear ode using ode45</p>
<p>Details: Solve the IVP</p>
<p>
<tt>y' = 1 / y^2 , y(1) = 1</tt>
</p>
<p>from <tt>t=1</tt> to <tt>t=10</tt> using <tt>ode45</tt>. Find the exact solution and compute the maximum pointwise error.</p>
<p>Then plot the approximate solution and the exact solution on the same axes. --&gt; I plotted</p>
<pre class="codeinput">f = @(t,y) 1/(y^2)
<span class="comment">% The initial conditions</span>
t0 = 1;
y0 = 1;
<span class="comment">% The time we will integrate until</span>
t1 = 10;
sol_45 = ode45(f, [t0, t1], y0);
disp(sol_45);
<span class="comment">% Now solve by hand.</span>
<span class="comment">% This is seperable integration, therefore, its bit easier to solve.</span>
<span class="comment">% move around around till getting (y^3)/3 = x + C</span>
<span class="comment">%y^3 = 3x + 3c</span>
<span class="comment">% y = (3x + 3c)^ 1/3</span>
<span class="comment">% put initial conditions:</span>
<span class="comment">% c = -2/3</span>
<span class="comment">% Therefore, solution is y = (3x-2)^(1/3)</span>
t_t = linspace(1, 10, 50);
y_y = (3*t_t-2).^(1/3);
plot(t_t, y_y, sol_45.x, sol_45.y, <span class="string">'x'</span>, <span class="string">'MarkerSize'</span>,10, <span class="string">'LineWidth'</span>, 2);
legend(<span class="string">'By Hand'</span>, <span class="string">'ODE 45'</span>,<span class="string">'Location'</span>,<span class="string">'Best'</span>);
title(<span class="string">"Exercise 4"</span>)
<span class="comment">% NOW MAXIMUM</span>
yexact_hi = ((3*(sol_45.x)-2)).^(1/3);
ERROR1 = abs(yexact_hi - sol_45.y)
disp(ERROR1);
fprintf(<span class="string">"Maximum ERROR: %g \n"</span>, max(ERROR1));
<span class="comment">% Maximum ERROR: 0.0017118</span>
<span class="comment">% Add a label to the axis and a legend</span>
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">"y"</span>);
</pre>
<pre class="codeoutput">
f =

  function_handle with value:

    @(t,y)1/(y^2)

     solver: 'ode45'
    extdata: [1&times;1 struct]
          x: [1 1.2010 2.1010 3.0010 3.9010 4.8010 5.7010 &hellip; ] (1&times;12 double)
          y: [1 1.1703 1.6248 1.9119 2.1319 2.3139 2.4711 &hellip; ] (1&times;12 double)
      stats: [1&times;1 struct]
      idata: [1&times;1 struct]


ERROR1 =

  Columns 1 through 7

         0    0.0000    0.0017    0.0012    0.0010    0.0008    0.0007

  Columns 8 through 12

    0.0007    0.0006    0.0006    0.0005    0.0005

  Columns 1 through 7

         0    0.0000    0.0017    0.0012    0.0010    0.0008    0.0007

  Columns 8 through 12

    0.0007    0.0006    0.0006    0.0005    0.0005

Maximum ERROR: 0.0017118 
</pre>
<img vspace="5" hspace="5" src="lab2_shinja19_05.png" alt=""> <p>Your solution should show the definition of the inline function, the computation of its solution in this interval, the computation of the exact solution at the computed grid points, the computation of the maximum error, and a plot of the exact and approximate solutions.</p>
<pre class="codeinput">
<span class="comment">%Your axes should be appropriately labeled and include a legend.</span>
</pre>
<h2 id="16">Exercise 5</h2>
<p>Objective: Solve and visualize an ODE that cannot be solved by hand with <tt>ode45</tt>.</p>
<p>Details: Solve the IVP</p>
<p>
<tt>y' = 1 - t y / 2, y(0) = -1</tt>
</p>
<p>from <tt>t=0</tt> to <tt>t=10</tt>
</p>
<pre class="codeinput">f = @(t,y) 1-t*y/2;
<span class="comment">% The initial conditions</span>
t0 = 0;
y0 = -1;
t1 = 10;
sol45 = ode45(f, [t0, t1], y0);
plot(sol45.x, sol45.y, <span class="string">'LineWidth'</span>, 2);
xlabel(<span class="string">"t"</span>)
ylabel(<span class="string">"y"</span>)
title(<span class="string">"Exercise 5"</span>)
legend(<span class="string">"By ODE45"</span>)
</pre>
<img vspace="5" hspace="5" src="lab2_shinja19_06.png" alt=""> <p>Your solution should show you defining the inline function, computing the solution in this interval, and plotting it.</p>
<p>Your axes should be appropriately labeled</p>
<h2 id="18">Exercise 6 - When things go wrong</h2>
<p>Objective: Solve an ode and explain the warning message</p>
<p>Details: Solve the IVP:</p>
<p>
<tt>y' = y^3 - t^2, y(0) = 1</tt>
</p>
<p>from <tt>t=0</tt> to <tt>t=1</tt>.</p>
<pre class="codeinput">f = @(t,y) y.^3 -t.^2;
t0 = 0;
y0 = 1;
t1 = 1;
so_l45 = ode45(f, [t0, t1], y0);
disp(so_l45);
plot(so_l45.x, so_l45.y, <span class="string">'LineWidth'</span>, 2);
xlabel(<span class="string">"t"</span>)
ylabel(<span class="string">"y"</span>)
title(<span class="string">"Exercise 6"</span>)
legend(<span class="string">"By ODE45"</span>)
<span class="comment">% when it goes a little bit above 0.5, it goes up to</span>
<span class="comment">% ~10.^7</span>
<span class="comment">% The reason why this generates error message:</span>
<span class="comment">% is because the from looking at iode, I can see that discontinuity at</span>
<span class="comment">% time t = 0.5 The solution of the curve becomes really stiff around that</span>
<span class="comment">% time will small step size. Therefore, this can't integrate properly. The</span>
<span class="comment">% reason why this became this can be "x^3" rate of change is too stiff.</span>
</pre>
<pre class="codeoutput">     solver: 'ode45'
    extdata: [1&times;1 struct]
          x: [0 0.1000 0.2000 0.3000 0.4000 0.4359 0.4719 &hellip; ] (1&times;79 double)
          y: [1 1.1177 1.2876 1.5664 2.1736 2.6658 3.7974 &hellip; ] (1&times;79 double)
      stats: [1&times;1 struct]
      idata: [1&times;1 struct]

</pre>
<img vspace="5" hspace="5" src="lab2_shinja19_07.png" alt=""> <p>Your solution should show you defining the inline function, and computing the solution in this interval.</p>
<p>If you try to plot the solution, you should find that the solution does not make it all the way to t = 1.</p>
<p>In the comments explain why MATLAB generates the warning message that you may see, or fails to integrate all the way to t=1. HINT: Try plotting the direction field for this with IODE.</p>
<h2 id="20">Using symbolic variables to define functions</h2>
<p>We can define symbolic variables to let MATLAB know that these variables will be used for exact computations</p>
<pre class="codeinput">
<span class="comment">% Start by defining the variables as symbolic</span>
syms <span class="string">t</span> <span class="string">s</span> <span class="string">x</span> <span class="string">y</span>

<span class="comment">% Define a function by simply writing its expression</span>

f = cos(t)
g = sin(t)
h = exp(2*x)

<span class="comment">% We can manipulate these functions</span>

simplify(f^2+g^2)
diff(h)

<span class="comment">% We can plot a function defined symbolically using the command |ezplot|.</span>
<span class="comment">% Learn about the command |ezplot|:</span>

help <span class="string">ezplot</span>

<span class="comment">% Plot the function |f(t)| and |h(x)|</span>

ezplot(f)
ezplot(h)
</pre>
<pre class="codeoutput"> 
f =
 
cos(t)
 
 
g =
 
sin(t)
 
 
h =
 
exp(2*x)
 
 
ans =
 
1
 
 
ans =
 
2*exp(2*x)
 
 EZPLOT   (NOT RECOMMENDED) Easy to use function plotter
 
  ==========================================================
  EZPLOT is not recommended. Use FPLOT or FIMPLICIT instead.
  ==========================================================
 
    EZPLOT(FUN) plots the function FUN(X) over the default domain
    -2*PI &lt; X &lt; 2*PI, where FUN(X) is an explicitly defined function of X.
 
    EZPLOT(FUN2) plots the implicitly defined function FUN2(X,Y) = 0 over
    the default domain -2*PI &lt; X &lt; 2*PI and -2*PI &lt; Y &lt; 2*PI.
 
    EZPLOT(FUN,[A,B]) plots FUN(X) over A &lt; X &lt; B.
    EZPLOT(FUN2,[A,B]) plots FUN2(X,Y) = 0 over A &lt; X &lt; B and A &lt; Y &lt; B.
 
    EZPLOT(FUN2,[XMIN,XMAX,YMIN,YMAX]) plots FUN2(X,Y) = 0 over
    XMIN &lt; X &lt; XMAX and YMIN &lt; Y &lt; YMAX.
 
    EZPLOT(FUNX,FUNY) plots the parametrically defined planar curve FUNX(T)
    and FUNY(T) over the default domain 0 &lt; T &lt; 2*PI.
 
    EZPLOT(FUNX,FUNY,[TMIN,TMAX]) plots FUNX(T) and FUNY(T) over
    TMIN &lt; T &lt; TMAX.
 
    EZPLOT(FUN,[A,B],FIG), EZPLOT(FUN2,[XMIN,XMAX,YMIN,YMAX],FIG), or
    EZPLOT(FUNX,FUNY,[TMIN,TMAX],FIG) plots the function over the
    specified domain in the figure window FIG.
 
    EZPLOT(AX,...) plots into AX instead of GCA or FIG.
 
    H = EZPLOT(...) returns handles to the plotted objects in H.
 
    Examples:
    The easiest way to express a function is via a string:
       ezplot('x^2 - 2*x + 1')
 
    One programming technique is to vectorize the string expression using
    the array operators .* (TIMES), ./ (RDIVIDE), .\ (LDIVIDE), .^ (POWER).
    This makes the algorithm more efficient since it can perform multiple
    function evaluations at once.
       ezplot('x.*y + x.^2 - y.^2 - 1')
 
    You may also use a function handle to an existing function. Function
    handles are more powerful and efficient than string expressions.
       ezplot(@humps)
       ezplot(@cos,@sin)
 
    EZPLOT plots the variables in string expressions alphabetically.
       subplot(1,2,1), ezplot('1./z - log(z) + log(-1+z) + t - 1')
    To avoid this ambiguity, specify the order with an anonymous function:
       subplot(1,2,2), ezplot(@(z,t)1./z - log(z) + log(-1+z) + t - 1)
 
    If your function has additional parameters, for example k in myfun:
       %-----------------------%
       function z = myfun(x,y,k)
       z = x.^k - y.^k - 1;
       %-----------------------%
    then you may use an anonymous function to specify that parameter:
       ezplot(@(x,y)myfun(x,y,2))
 
    See also EZCONTOUR, EZCONTOURF, EZMESH, EZMESHC, EZPLOT3, EZPOLAR,
             EZSURF, EZSURFC, PLOT, VECTORIZE, FUNCTION_HANDLE.

    Documentation for ezplot
       doc ezplot

    Other uses of ezplot

       sym/ezplot

</pre>
<img vspace="5" hspace="5" src="lab2_shinja19_08.png" alt=""> <p>If we try to evaluate the function <tt>f(0)</tt>, we get an error message.</p>
<p>The symbolic variables are not meant to be used to evaluate functions, but to manipulate functions, compute derivatives, etc. To evaluate a function using symbolic variables is a little cumbersome:</p>
<pre class="codeinput">
<span class="comment">% We need to substitute the variable by a value:</span>

subs(f,t,pi)
</pre>
<pre class="codeoutput"> 
ans =
 
-1
 
</pre>
<p>This expression means: In the expression <tt>f</tt>, substitute the variable <tt>t</tt> by the number <tt>pi</tt>.</p>
<pre class="codeinput">
<span class="comment">% If we use a value where the cosine does not have a "nice" expression, we</span>
<span class="comment">% need to approximate the result:</span>

subs(f,t,2)

<span class="comment">% We need to use the command |eval|</span>

eval(subs(f,t,2))
</pre>
<pre class="codeoutput"> 
ans =
 
cos(2)
 

ans =

   -0.4161

</pre>
<h2 id="23">Exercise 7</h2>
<p>Objective: Define a function using symbolic variables and manipulate it.</p>
<p>Details: Define the function <tt>f(x) = sin(x)cos(x)</tt>
</p>
<p>Use MATLAB commands to obtain a simpler form of this function, compute value of this function for <tt>x=pi/4</tt> and <tt>x=1</tt>, and plot its graph.</p>
<pre class="codeinput">
<span class="comment">% Start by defining the variables as symbolic</span>
syms <span class="string">hi</span> <span class="string">f</span> <span class="string">x</span>

<span class="comment">% Define a function by simply writing its expression</span>

f = sin(x)*cos(x)
<span class="comment">% We can manipulate these functions</span>

hi = simplify(f)

<span class="comment">% Evaulate value at pi/4</span>
subs(hi, x, pi/4)
<span class="comment">% sym(1/2)</span>
<span class="comment">% Evaulate value at 1</span>
eval(subs(hi, x, 1))
<span class="comment">% ans = 0.4546</span>

ezplot(hi)
</pre>
<pre class="codeoutput"> 
f =
 
cos(x)*sin(x)
 
 
hi =
 
sin(2*x)/2
 
 
ans =
 
1/2
 

ans =

    0.4546

</pre>
<img vspace="5" hspace="5" src="lab2_shinja19_09.png" alt=""> <h2 id="24">Obtaining Picard approximations</h2>
<p>Consider an initial value problem</p>
<p>
<tt>y' = 1 + y</tt> <tt>y(0) = 0</tt>
</p>
<p>First we need to define the variables we will be using</p>
<pre class="codeinput">syms <span class="string">t</span> <span class="string">s</span> <span class="string">y</span>;

<span class="comment">% We then need to define the function f</span>

hi = 1+y; <span class="comment">% we define it without the @(t,y) because it is a symbolic function</span>

<span class="comment">% We set up our initial approximation phi_0 = 0:</span>

phi=[sym(0)];   <span class="comment">% we will keep a list with all the approximations</span>
phi

<span class="comment">% Set up a loop to get successive approximations using Picard iterations</span>

N=5;

<span class="keyword">for</span> i = 1:N
    func=subs(hi,y,phi(i));    <span class="comment">% prepare function to integrate: y -&gt; previous phi</span>
    func=subs(func,t,s);      <span class="comment">% variable of integration is s, so we need to change</span>
    <span class="comment">% t -&gt; s</span>

    newphi = int(func, s, 0 ,t);   <span class="comment">% integrate to find next approximation</span>

    phi=cat(2,phi,[newphi]);       <span class="comment">% update the list of approximations by adding new phi</span>
<span class="keyword">end</span>

<span class="comment">% Show the last approximation</span>

phi(N+1)

<span class="comment">% Plot the approximation just found</span>

picard=ezplot(phi(N+1),[0,5]);
set(picard,<span class="string">'Color'</span>,<span class="string">'green'</span>);         <span class="comment">% set the color of the graph to green</span>

<span class="comment">% In this case, the exact solution is</span>
<span class="comment">%</span>
<span class="comment">% |y=e^t-1|</span>
<span class="comment">%</span>
<span class="comment">% Compare the approximation and the exact solutions</span>

hold <span class="string">on</span>;
exact=ezplot(exp(t)-1,[0,5]);

xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'y'</span>);
title(<span class="string">'Picard Approximations'</span>);
legend(<span class="string">'Picard Approximation'</span>, <span class="string">'Exact Solution'</span>,<span class="string">'Location'</span>,<span class="string">'NorthWest'</span>);
</pre>
<pre class="codeoutput"> 
phi =
 
0
 
 
ans =
 
(t*(t^4 + 5*t^3 + 20*t^2 + 60*t + 120))/120
 
</pre>
<img vspace="5" hspace="5" src="lab2_shinja19_10.png" alt=""> <h2 id="25">Exercise 8</h2>
<pre>Objective: Solve your own Picard Approximation and compare it to the
exact solution.</pre>
<pre>Details: Consider the IVP
   | y' = 1+y^2|
   | y(0) = 1 |</pre>
<pre class="codeinput">clear;
clf;
syms <span class="string">t</span> <span class="string">s</span> <span class="string">y</span>;

lol = 1+y.^2;

<span class="comment">% We set up our initial approximation phi_hi = 1:</span>
phi_hi = sym(1)
<span class="comment">% In terms of efficiency, don't store old phis</span>

<span class="comment">% Set up a loop to get successive approximations using Picard iterations</span>
N=5; <span class="comment">% To get phi_hi_5</span>

<span class="keyword">for</span> i = 1:N
    func=subs(lol,y,phi_hi);
    func=subs(func,t,s);
    phi_hi = 1 + int(func, s, 0 ,t);   <span class="comment">% integrate to find next approximation</span>
<span class="keyword">end</span>

<span class="comment">% Show the last approximation</span>

phi_hi
<span class="comment">% Plot the approximation just found</span>

picard=ezplot(phi_hi,[0,2]);
set(picard,<span class="string">'Color'</span>,<span class="string">'green'</span>);         <span class="comment">% set the color of the graph to green</span>

hold <span class="string">on</span>;
exact=ezplot(tan(pi/4 + t),[0,2]);
hold <span class="string">off</span>;
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'y'</span>);
title(<span class="string">'Exerciese 8: Picard Approximations'</span>);
legend(<span class="string">'Picard Approximation'</span>, <span class="string">'Exact Solution'</span>,<span class="string">'Location'</span>,<span class="string">'NorthWest'</span>);
</pre>
<pre class="codeoutput"> 
phi_hi =
 
1
 
 
phi_hi =
 
(65536*t^31)/109876902975 + (32768*t^30)/3544416225 + (33636352*t^29)/445414972275 + (2189312*t^28)/5119712325 + (3771621376*t^27)/2017062172125 + (3496164352*t^26)/522942044625 + (1852466944*t^25)/91423434375 + (28632512*t^24)/536350815 + (234841821952*t^23)/1884677169375 + (14839805056*t^22)/56729413125 + (1241511104*t^21)/2483105625 + (400722032*t^20)/456080625 + (1157035136*t^19)/808782975 + (4159073344*t^18)/1915538625 + (1240970116*t^17)/402026625 + (175768612*t^16)/42567525 + (1111144976*t^15)/212837625 + (29636504*t^14)/4729725 + (4842328*t^13)/675675 + (1221016*t^12)/155925 + (425608*t^11)/51975 + (1108*t^10)/135 + (22376*t^9)/2835 + (764*t^8)/105 + (32*t^7)/5 + (16*t^6)/3 + (64*t^5)/15 + (10*t^4)/3 + (8*t^3)/3 + 2*t^2 + 2*t + 1
 
</pre>
<img vspace="5" hspace="5" src="lab2_shinja19_11.png" alt=""> <p>Find the Picard approximation phi_5. For better efficiency, do not keep all the previous approximations.</p>
<p>Compute the exact solution (by hand), and plot both on the same figure for comparison, as above.</p>
<p>Label your axes and include a legend.</p>
<p>HINT. The initial condition has 1 instead of 0, so the Picard method needs to be adapted.</p>
<p class="footer">
<br>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2023b</a>
<br>
</p>
</div>
<!--
##### SOURCE BEGIN #####
%% Integrator Lab: Solving First Order ODEs in MATLAB and Picard Approximation
% This lab will teach you to numerically solve first order ODEs using a built 
% in MATLAB integrator, |ode45|.  |ode45| is a good, general purpose tool for 
% integrating first order equations (and first order systems). It is not always 
% the right algorithm, but it is usually the right algorithm to try first. This 
% lab will also teach you how to manipulate symbolic functions in MATLAB.
% 
% You will learn how to use the |ode45| routine, how to interpolate between 
% points, and how MATLAB handles data structures. You will also learn how to use 
% MATLAB for exact symbolic calculations and write your own Picard approximation 
% code.
% 
% Opening the m-file lab2.m in the MATLAB editor, step through each part using 
% cell mode to see the results. Compare the output with the PDF, which was generated 
% from this m-file.
% 
% There are eight exercises in this lab that are to be handed in at the end 
% of the lab. Write your solutions in the template, including appropriate descriptions 
% in each step. Save the .m file and submit it online using Quercus.
%% Student Information
% Student Name: Jaehah Shin
% 
% Student Number: 1008851137
%% Set up an inline function representation of an ODE and solve it
% MATLAB has many built in routines for solving differential equations of the 
% form
% 
% |y' = f(t,y)|
% 
% We will solve them using |ode45|, a high precision integrator. To do this, 
% we will need to construct an inline function representation of |f|, an initial 
% condition, and specify how far we want MATLAB to integrate the problem. Once 
% we have set these, we pass the information to |ode45| to get the solution.
% 
% For a first example, we will solve the initial value problem
% 
% |y' = y, y(0) = 1|
% 
% which has as its answer |y = e^t|.

% Set up the right hand side of the ODE as an inline function
f = @(t,y) y;

% The initial conditions
t0 = 0;
y0 = 1;

% The time we will integrate until
t1 = 2;

soln = ode45(f, [t0, t1], y0);
%% Examining the output
% When we execute the |ode45|, it returns a data structure, stored in soln. 
% We can see the pieces of the data structure with a display command:

disp(soln);
%% Understanding the components of the solution data structure
% The most important elements of the data structure are stored in the |x| and 
% |y| components of the structure; these are vectors. Vectors |x| and |y| contain 
% the points at which the numerical approximation to the initial vlaue problem 
% has been computed. In other words, |y(j)| is the approximate value of the solution 
% at |x(j)|.
% 
% *NOTE:* Even though we may be studying a problem like |u(t)| or |y(t)|, MATLAB 
% will always use |x| for the independent variable and |y| for the dependent variable 
% in the data structure.
% 
% Pieces of the data structure can be accessed using a period, as in C/C++ or 
% Java. See the examples below:

% Display the values of |t| at which |y(t)| is approximated
fprintf(' Vector of t values: ');
disp(soln.x);
% Display the the corresponding approximatations of |y(t)|
fprintf(' Vector of y values: ');
disp(soln.y);

% Display the approximation of the solution at the 3rd point:
fprintf(' Third element of the vector of t values: %g\n',soln.x(3));
fprintf(' Third element of the vector of y values: %g\n',soln.y(3));
%% Visualizing and comparing the solution
% We can now visualize the solution at the computed data points and compare 
% with the exact solution.

% Construct the exact solution
tt = linspace(0,2,50);
yy = exp(tt);

% Plot both on the same figure, plotting the approximation with x's
plot(tt, yy, soln.x, soln.y, 'x', 'MarkerSize',10, 'LineWidth', 2);
% NOTE: the MarkerSize and LineWidth are larger than their defaults of 6
% and 1, respectively.  This makes the print out more readable.

% Add a label to the axis and a legend
xlabel('t');
legend('Exact', 'Numerical','Location','Best');
%% Exercise 1
% Objective: Solve an initial value problem and plot both the numerical approximation 
% and the corresponding exact solution.
% 
% Details: Solve the IVP
% 
% |y' = y tan t + sin t, y(0) = -1/2|
% 
% from |t = 0| to |t = pi|.
% 
% Compute the exact solution (by hand), and plot both on the same figure for 
% comparison, as above.

% Set up the right hand side of the ODE as an inline function
f = @(t,y) y*tan(t) + sin(t);

% The initial conditions
t0 = 0;
y0 = -1/2;

% The time we will integrate until
t1 = pi;

sol_by_45 = ode45(f, [t0, t1], y0);
disp(sol_by_45);
%      solver: 'ode45'
%    extdata: [1×1 struct]
%          x: [0 0.3142 0.6283 0.9425 1.2566 1.2881 1.3195 1.4765 1.5177 1.5588 1.6491 1.7455 2.0597 2.3739 2.6880 3.0022 3.1416]
%          y: [-0.5000 -0.4755 -0.4045 -0.2939 -0.1545 -0.1395 -0.1243 -0.0471 -0.0266 -0.0060 0.0391 0.0869 0.2348 0.3597 0.4494 0.4951 0.5000]
%      stats: [1×1 struct]
%      idata: [1×1 struct]

% Now solve by hand.

% use integartion factor to solve this. 
% This will lead to y = (sin^2t / 2cost) -0.5 /cost
% (y = sin^2(t)/2cost) + C/cost before putting intinal conditions)
% By solving constant with intial condition yields
% C = -0.5, which will lead to above equation.
tt = linspace(0, pi, 50);
yy = (sin(tt).^2)./(2*cos(tt)) - 0.5./(cos(tt));



% Plot both on the same figure, plotting the approximation with x's
plot(tt, yy, sol_by_45.x, sol_by_45.y, 'x', 'MarkerSize',10, 'LineWidth', 2);
% NOTE: the MarkerSize and LineWidth are larger than their defaults of 6
% and 1, respectively.  This makes the print out more readable.

% Add a label to the axis and a legend
xlabel('t');
ylabel("y");
legend('By Hand', 'ODE 45','Location','Best');
title("Exercise 1: Hand vs. ODE 45")


%% 
% Your submission should show the construction of the inline function, the use 
% of ode45 to obtain the solution, a construction of the exact solution, and a 
% plot showing both. In the comments, include the exact solution.
% 
% Label your axes and include a legend.
%% Computing an approximation at a specific point
% As you should be able to see by examining |soln.x|, ode45 returns the solution 
% at a number of points between |t0| and |t1|. But sometimes we want to know the 
% solution at some intermediate point.
% 
% To obtain this value, we need to interpolate it in a consistent way. Fortunately, 
% MATLAB provides a convenient function, |deval|, specifically for this.

% Compute the solution at t = .25:
deval(soln, .25)

% Compute the solution at t = 1.6753:
fprintf(' Solution at 1.6753: %g\n', deval(soln, 1.6753));

% Compute the solution at 10 grid points between .45 and 1.65:
tinterp = linspace(.45, 1.65, 10);
deval(soln, tinterp)

% Alternatively:
deval(soln, linspace(.45, 1.65, 10))
%% Exercise 2
% Objective: Interpolate a solution at a number of grid points

hi = deval(sol_by_45, linspace(2,3,10))
disp(hi);

% double check where the bottom colum come from 
%% 
% Details: For the solution you computed in exercise 1, use deval to compute 
% the interpolated values at 10 grid points between 2 and 3.
%% Errors, Step Sizes, and Tolerances
% As you may have noticed, in contrast to the IODE software, at no point do 
% we set a step size for our solution. Indeed, the step size is set adaptively 
% to conform to a specified error tolerance.
% 
% Roughly speaking, given the solution at |(t_j, y_j)|, |ode45| computes two 
% approximations of the solution at |t_{j+1} = t_j + h|; one is of greater accuracy 
% than the other. If the difference is below a specified tolerance, the step is 
% accepted and we continue. Otherwise the step is rejected and the smaller step 
% size, |h|, is used; it is often halved.
% 
% We can compute the global truncation error at each solution point, figure 
% out the maximum error, and visualize this error (on a linear-log scale):

% Compute the exact solution
yexact = exp(soln.x);

% Compute the pointwise error; note the use of MATLAB's vectorization
err = abs(yexact - soln.y);

disp(err);

fprintf('maximum error: %g \n', max(err));

semilogy(soln.x, err, 'LineWidth', 2);
xlabel('t');
ylabel('error');
%% Exercise 3
% Objective: Examine the error of a solution generated by |ode45|

% computing the exact solutino:
yexact = (sin(sol_by_45.x).^2)./(2*cos(sol_by_45.x)) - 0.5./(cos(sol_by_45.x));

% Error?
ERROR = abs(yexact - sol_by_45.y);
disp(ERROR);
fprintf("Maximum ERROR: %g \n", max(ERROR));
% Maximum ERROR: 1.8068e-05 

% Error is largest at that point near t = 1.5,
% the reason because it has the largest error is as at @ 1.5s is the rate of
% chage of the derivate is the higest. Smaller steps
% sizes are required to reduce the error. 
semilogy(sol_by_45.x, ERROR, "LineWidth", 2);
xlabel("t");
ylabel("ERROR");
title("Exercise 3")
%% 
% Details: For your solution to exercise 1, compute the pointwise error, identify 
% the maximum value of the error, and visualize the error on a linear-log plot 
% (use semilogy to plot the log of the error vs. t). Write in the comments where 
% the error is largest, and give a brief (1-2 sentences) explanation of why it 
% is largest there. Make sure to label your axes.
%% Exercise 4
% Objective: Solve and visualize a nonlinear ode using ode45
% 
% Details: Solve the IVP
% 
% |y' = 1 / y^2 , y(1) = 1|
% 
% from |t=1| to |t=10| using |ode45|. Find the exact solution and compute the 
% maximum pointwise error. 
% 
% Then plot the approximate solution and the exact solution on the same axes. 
% REPLACE_WITH_DASH_DASH> I plotted

f = @(t,y) 1/(y^2)
% The initial conditions
t0 = 1;
y0 = 1;
% The time we will integrate until
t1 = 10;
sol_45 = ode45(f, [t0, t1], y0);
disp(sol_45);
% Now solve by hand.
% This is seperable integration, therefore, its bit easier to solve.
% move around around till getting (y^3)/3 = x + C
%y^3 = 3x + 3c
% y = (3x + 3c)^ 1/3
% put initial conditions:
% c = -2/3
% Therefore, solution is y = (3x-2)^(1/3)
t_t = linspace(1, 10, 50);
y_y = (3*t_t-2).^(1/3);
plot(t_t, y_y, sol_45.x, sol_45.y, 'x', 'MarkerSize',10, 'LineWidth', 2);
legend('By Hand', 'ODE 45','Location','Best');
title("Exercise 4")
% NOW MAXIMUM
yexact_hi = ((3*(sol_45.x)-2)).^(1/3);
ERROR1 = abs(yexact_hi - sol_45.y)
disp(ERROR1);
fprintf("Maximum ERROR: %g \n", max(ERROR1));
% Maximum ERROR: 0.0017118 
% Add a label to the axis and a legend
xlabel('t');
ylabel("y");
%% 
% Your solution should show the definition of the inline function, the computation 
% of its solution in this interval, the computation of the exact solution at the 
% computed grid points, the computation of the maximum error, and a plot of the 
% exact and approximate solutions.

%Your axes should be appropriately labeled and include a legend.
%% Exercise 5
% Objective: Solve and visualize an ODE that cannot be solved by hand with |ode45|.
% 
% Details: Solve the IVP
% 
% |y' = 1 - t y / 2, y(0) = -1|
% 
% from |t=0| to |t=10|

f = @(t,y) 1-t*y/2;
% The initial conditions
t0 = 0;
y0 = -1;
t1 = 10;
sol45 = ode45(f, [t0, t1], y0);
plot(sol45.x, sol45.y, 'LineWidth', 2);
xlabel("t")
ylabel("y")
title("Exercise 5")
legend("By ODE45")
%% 
% Your solution should show you defining the inline function, computing the 
% solution in this interval, and plotting it.
% 
% Your axes should be appropriately labeled
%% Exercise 6 - When things go wrong
% Objective: Solve an ode and explain the warning message
% 
% Details: Solve the IVP:
% 
% |y' = y^3 - t^2, y(0) = 1|
% 
% from |t=0| to |t=1|.

f = @(t,y) y.^3 -t.^2;
t0 = 0;
y0 = 1;
t1 = 1;
so_l45 = ode45(f, [t0, t1], y0);
disp(so_l45);
plot(so_l45.x, so_l45.y, 'LineWidth', 2);
xlabel("t")
ylabel("y")
title("Exercise 6")
legend("By ODE45")
% when it goes a little bit above 0.5, it goes up to 
% ~10.^7
% The reason why this generates error message: 
% is because the from looking at iode, I can see that discontinuity at
% time t = 0.5 The solution of the curve becomes really stiff around that
% time will small step size. Therefore, this can't integrate properly. The
% reason why this became this can be "x^3" rate of change is too stiff. 
%% 
% Your solution should show you defining the inline function, and computing 
% the solution in this interval.
% 
% If you try to plot the solution, you should find that the solution does not 
% make it all the way to t = 1.
% 
% In the comments explain why MATLAB generates the warning message that you 
% may see, or fails to integrate all the way to t=1. HINT: Try plotting the direction 
% field for this with IODE.
%% Using symbolic variables to define functions
% We can define symbolic variables to let MATLAB know that these variables will 
% be used for exact computations

% Start by defining the variables as symbolic
syms t s x y

% Define a function by simply writing its expression

f = cos(t)
g = sin(t)
h = exp(2*x)

% We can manipulate these functions

simplify(f^2+g^2)
diff(h)

% We can plot a function defined symbolically using the command |ezplot|.
% Learn about the command |ezplot|:

help ezplot

% Plot the function |f(t)| and |h(x)|

ezplot(f)
ezplot(h)
%% 
% If we try to evaluate the function |f(0)|, we get an error message.
% 
% The symbolic variables are not meant to be used to evaluate functions, but 
% to manipulate functions, compute derivatives, etc. To evaluate a function using 
% symbolic variables is a little cumbersome:

% We need to substitute the variable by a value:

subs(f,t,pi)
%% 
% This expression means: In the expression |f|, substitute the variable |t| 
% by the number |pi|.

% If we use a value where the cosine does not have a "nice" expression, we
% need to approximate the result:

subs(f,t,2)

% We need to use the command |eval|

eval(subs(f,t,2))
%% Exercise 7
% Objective: Define a function using symbolic variables and manipulate it.
% 
% Details: Define the function |f(x) = sin(x)cos(x)|
% 
% Use MATLAB commands to obtain a simpler form of this function, compute value 
% of this function for |x=pi/4| and |x=1|, and plot its graph.

% Start by defining the variables as symbolic
syms hi f x

% Define a function by simply writing its expression

f = sin(x)*cos(x)
% We can manipulate these functions

hi = simplify(f)

% Evaulate value at pi/4
subs(hi, x, pi/4)
% sym(1/2)
% Evaulate value at 1
eval(subs(hi, x, 1))
% ans = 0.4546

ezplot(hi)

%% Obtaining Picard approximations
% Consider an initial value problem
% 
% |y' = 1 + y| |y(0) = 0|
% 
% First we need to define the variables we will be using

syms t s y;

% We then need to define the function f

hi = 1+y; % we define it without the @(t,y) because it is a symbolic function

% We set up our initial approximation phi_0 = 0:

phi=[sym(0)];   % we will keep a list with all the approximations
phi

% Set up a loop to get successive approximations using Picard iterations

N=5;

for i = 1:N
    func=subs(hi,y,phi(i));    % prepare function to integrate: y -> previous phi
    func=subs(func,t,s);      % variable of integration is s, so we need to change
    % t -> s
    
    newphi = int(func, s, 0 ,t);   % integrate to find next approximation
    
    phi=cat(2,phi,[newphi]);       % update the list of approximations by adding new phi
end

% Show the last approximation

phi(N+1)

% Plot the approximation just found

picard=ezplot(phi(N+1),[0,5]);
set(picard,'Color','green');         % set the color of the graph to green

% In this case, the exact solution is
%
% |y=e^t-1|
%
% Compare the approximation and the exact solutions

hold on;
exact=ezplot(exp(t)-1,[0,5]);

xlabel('t');
ylabel('y');
title('Picard Approximations');
legend('Picard Approximation', 'Exact Solution','Location','NorthWest');
%% Exercise 8
%%
% 
%  Objective: Solve your own Picard Approximation and compare it to the
%  exact solution.
%
%%
% 
%  Details: Consider the IVP
%     | y' = 1+y^2|
%     | y(0) = 1 |
%

clear;
clf;
syms t s y;

lol = 1+y.^2; 

% We set up our initial approximation phi_hi = 1:
phi_hi = sym(1)
% In terms of efficiency, don't store old phis 

% Set up a loop to get successive approximations using Picard iterations
N=5; % To get phi_hi_5

for i = 1:N
    func=subs(lol,y,phi_hi);   
    func=subs(func,t,s);     
    phi_hi = 1 + int(func, s, 0 ,t);   % integrate to find next approximation
end

% Show the last approximation

phi_hi
% Plot the approximation just found

picard=ezplot(phi_hi,[0,2]);
set(picard,'Color','green');         % set the color of the graph to green

hold on;
exact=ezplot(tan(pi/4 + t),[0,2]);
hold off;
xlabel('t');
ylabel('y');
title('Exerciese 8: Picard Approximations');
legend('Picard Approximation', 'Exact Solution','Location','NorthWest');
%% 
% Find the Picard approximation phi_5. For better efficiency, do not keep all 
% the previous approximations.
% 
% Compute the exact solution (by hand), and plot both on the same figure for 
% comparison, as above.
% 
% Label your axes and include a legend.
% 
% HINT. The initial condition has 1 instead of 0, so the Picard method needs 
% to be adapted.
##### SOURCE END #####
-->
</body>
</html>
